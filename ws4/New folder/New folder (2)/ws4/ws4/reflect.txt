
Upon completing this Workshop 3: Templates, I learned a lot of new information that I implemented on this workshop in order to successfully execute all the code. First of all, I learned how to design and code a class template which can be declared without being defined by using an elaborated type specifier. Secondly, I also learned how to template a class variable. As per the information I found on the Seneca's ICT website for OOP345, a template declaration for a family of classes that include a class variable requires a complementary template declaration to define and initialize the family of class variables. Moreover, I also successfully specialized a templated class variable for a particular type. In addition, I instantiated a template class then specialized a member function of a templated class to process a particular type. Lastly, I learned how to attain a templated class from another templated class. 


Furthermore, there are situations where the logic provided in a template definition contains operations that would only work on specific types. The reason behind this is because of the fact that certain types may create ill-formed expressions as different types allow for different operations. We can include a template specialization in order to include types that would normally be prohibited by the compiler. Template specialization is a separate definition for the same identifier which includes (i.e., function, class, variable name) that declares the types in the body of the template and parameter list if it is a function. In this case, the template specialization that was used in this workshop is the 'add' member function. It returns the sum of the value in the current object and the value received in the parameter list. a specialization was required to space out the strings as they were concatenated to allow them to be shown to the user in a readable format. Additionally, class variables do not belong to any specific instance of the class because they are defined outside the class definition. The reason being is because it resides in the data segment within RAM. Only data members that belong tospecific instances of the class can be defined within the class. The definition outside the class ensures that there is only one definition for the class variable as it should only appear once the data segment.  
   